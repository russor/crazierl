#!/usr/local/bin/perl

use strict;
use warnings;
use Cwd;
use File::Basename;

my @FILES;
my @OTP_FILES=`cat preload_otp_files`;
chomp @OTP_FILES;

my $OUTPUTDIR=cwd() . '/fs_obj';
foreach (glob ("$OUTPUTDIR/*.o")) {
	unlink($_) || die "couldn't unlink $_";
}

open my $out, '>', 'files.c' or die "couldn't open output file";

my $curdir = cwd();
chdir "../otp_src_R12B-5" || die "couldn't chdir";

foreach my $f (@OTP_FILES) {
	next unless $f;
	push @FILES, $f;
	my $base = basename($f);
	system("objcopy -I binary -O elf32-i386-freebsd $f $OUTPUTDIR/$base.o") == 0 || die "couldn't objcopy $f";
}

chdir $curdir || die "couldn't chdir back to $curdir";
my @LOCAL_FILES=`cat preload_local_files`;
chomp @LOCAL_FILES;
foreach my $f (@LOCAL_FILES) {
	next unless $f;
	push @FILES, $f;
	my $base = basename($f);
	system("objcopy -I binary -O elf32-i386-freebsd $f $OUTPUTDIR/$base.o") == 0 || die "couldn't objcopy $f";
}


print $out <<'EOS';
// automatically generated by hardcode_files.pl
#include "files.h"
#include <string.h>

EOS
@FILES = sort (@FILES);
my @TOKENS;
foreach my $f (@FILES) {
	my $token = $f;
	$token =~ s@[\./]@_@g;
	$f =~ s@^/@@g;
	push @TOKENS, $token;
	print $out "extern void _binary_${token}_start;\n";
	print $out "extern void _binary_${token}_end;\n";
}

print $out "struct hardcoded_file hardcoded_files[" . scalar(@FILES) ."];\n";
print $out "void init_files() {\n";

for (my $i = 0; $i < @FILES; ++$i) {
	my $f = $FILES[$i];
	my $token = $TOKENS[$i];
	print $out <<EOS
	hardcoded_files[$i].name = \"/${f}\";
	hardcoded_files[$i].start = &_binary_${token}_start;
	hardcoded_files[$i].end = &_binary_${token}_end;
	hardcoded_files[$i].size = hardcoded_files[$i].end - hardcoded_files[$i].start;
EOS
}
print $out <<'EOS';
};

struct hardcoded_file * find_file(const char * name) {
	for (int i = 0; i < sizeof(hardcoded_files) / sizeof(*hardcoded_files); ++i) {
		int cmp = strcmp(name, hardcoded_files[i].name);
		if (cmp == 0) {
			return &(hardcoded_files[i]);
		} else if (cmp < 0) {
			return NULL;
		}
	} 
	return NULL;
}

struct hardcoded_file * find_dir(const char * name) {
	size_t len = strlen(name);
	for (int i = 0; i < sizeof(hardcoded_files) / sizeof(*hardcoded_files); ++i) {
		int cmp = strncmp(name, hardcoded_files[i].name, len);
		if (cmp == 0) {
			if (hardcoded_files[i].name[len] == '/') {
				return &(hardcoded_files[i]);
			}
		} else if (cmp < 0) {
			return NULL;
		}
	} 
	return NULL;
}
EOS
